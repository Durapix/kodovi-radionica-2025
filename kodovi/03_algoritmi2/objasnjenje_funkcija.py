# Пре овога погледати:
# objasnjenje_input.py

# Постоји велик број проблема који су већ решени и претворени у некакав програмски код.
# Да би могли да поново употребимо та решења, уместо да их стално опет правимо,
# користимо потпрограме - односно функције.
# Као што алгоритми имају улазе, стања, операције, и излазе, тако их имају и функције.
# Функције могу да користе друге функције

print ("##################################################")
print()

def funkcija_prazna():
    pass
# def је кључна реч која се користи да кажемо да смо почели да дефинишемо нешто
# funkcija_prazna је име коју смо дали нашој функцији
# pass је кључна реч која значи да не радимо ништа.
# Овде је да би компајлеру ставили до знања "Ја стварно нећу ништа да урадим овде"
# Када се ова функција покрене, ништа се неће десити осим траћења времена програма

# ПРОБЛЕМ:
# Свака функција је решење неког проблема.
# У случају функције print(), тај проблем је испис нечега на конзолу.
# У случају функције input(), тај проблем је унос нечега са конзоле, уз испис неког
# текста који кориснику треба да објасни шта треба да унесе.
# Свака функција има неки проблем који треба да реши, и то да ли функција ради
# како треба или не одређујемо на основу тога да ли (и колико добро) решава тај проблем

# Ова функција броји до 3, и на крају позива функцију input
def funkcija_broji_do_3():
    funkcija_prazna()
    brojac = 0
    brojac+=1
    brojac+=1
    brojac+=1
    input ("Одбројали смо до " + str(brojac) + ". Притисните ентер да наставите.")

# Приметите да је текст размакнут за један таб. Касније ћемо детаљније објаснити
# како ово ради, али за сада је довољно да знате да је све што је табулирано део
# дефиниције функције, и функција се завршава када престанемо да табулирамо

# Функција је овде дефинисана, али док је заправо и не позовемо, неће ништа радити.
# Хајде да је позовемо.
print ("Испод овог је позив функције funkcija_broji_do_3()")
funkcija_broji_do_3()
print()
# Променљива brojac постоји само унутар функције funkcija_broji_do_3.
# Не можемо је овде користити. Уклоните ### испред линије испод да проверите
### print (brojac)
# Настаће изузетак, и програм ће нам јавити следећу грешку:
# NameError: name 'brojac' is not defined
# Наш програм не види нигде променљиву brojac и не зна шта даље да ради


# ИЗЛАЗ:
# Излаз је нека коначна вредност коју нам наша функција шаље када се заврши.

def funkcija_vraca_uneseno():
    return input("Унесите нешто: ")

# Кључна реч return се користи да се програму каже шта је излаз из функције

print ()
print ("Унели сте:", funkcija_vraca_uneseno())
print ()

# За разлику од графа тока алгоритма, функција се завршава чим дођемо до излаза
# Ако желимо нешто да урадимо након што смо израчунали излаз, треба да сачувамо излаз
# у неку променљиву, и сачекамо до краја функције пре него што употребимо return

def funkcija_vraca_uneseno_i_javlja():
    izlaz = input("Унесите нешто: ")
    print ("Нешто је унето")
    return izlaz

print ("Унели сте:", funkcija_vraca_uneseno_i_javlja())

print ()
input ("Притисните ентер да наставите")
print ()

# Функција може имати више од једне излазне вредности. То се постиже тиме што се
# променљиве у које ће те вредности бити смештене наводе једна иза друге, са зарезом
# између.

def funkcija_vraca_dve_vrednosti():
    prva = 2
    druga = 5
    return prva, druga

# Можемо унети два резултата у две вредности, а онда те вредности употребити независно
a, b = funkcija_vraca_dve_vrednosti()
print ("Независне променљиве:", a, "+", b, "=", a+b)
print ()
# Ако покушамо да проследимо излаз ове функције као једну вредност, Пајтон ће да
# упише скуп (односно "торку") у који су уписани сви наши излази.
print ("Скуп:", funkcija_vraca_dve_vrednosti())
# О скуповима ћемо више причати током наредних часова.

print ()
input ("Притисните ентер да наставите")
print ()


# Функција не мора да има излаз. Ако покушамо да доделимо непостојећи излаз,
# десиће се следеће:

povratna_vrednost = print ("Функција print() нема повратну вредност")
print ("povratna_vrednost у коју смо сместили резултат print()-а је променљива која сада не садржи ништа.")
print (povratna_vrednost, "је Пајтонов начин да нам каже да нека променљива нема никакву вредност")

# Функције без излаза обично мењају неко унутрашње стање нашег програма.
# На пример, функција print() мења стање наше конзоле да би приказало оно што смо
# тој функцији проследили. Ми као корисници можемо сматрати испис на конзолу излазом,
# јер то представља податак у неком видљивом облику с којим можемо да радимо даље сами.

# Да не бих морао сваки пут да куцам 
# print()
# input("Притисните ентер да наставите"),
# print()
# Направићу малу функцију која то ради уместо мене

def dalje():
    print()
    input ("Притисните ентер да наставите")
    print()

# И сада могу да то користим у програму

dalje()

# УЛАЗ
# Улаз је нека вредност коју прослеђујемо функцији да би могла с њом да ради.
# На пример, када позивате функцију принт, прослеђујете јој шта да испише
# Функција може да има већи број улаза, који су раздвојени зарезом

def zbir (prvi_sabirak, drugi_sabirak):
    return prvi_sabirak + drugi_sabirak

# prvi_sabirak и drugi_sabirak су "параметри" функције zbir, 
# оно што ће да буде замењено улазним вредностима када функција буде позвана. 
# Вредности које проследимо функцији као улазне када је позовемо се зову "аргументи". 
# Уносе се истим редом којим су дати одговарајући параметри, 
# и мора их бити тачно онолико колико има параметара.

# Ова функција приме сабирке као улазе, врши операцију сабирања, и враћа збир као излаз
# Направили смо је да би решили проблем сабирања два броја

a = 2
b = 3
c = zbir(a,b)
print (a, "+", b, "=", c)
# Ова функција, без обзира на наше намере када смо је направили, ради још нешто

dalje()

a = "Лево"
b = "Десно"
c = zbir(a,b)
print (a, "+", b, "=", c)

# Као што видите, ова функција такође ради конкатенацију стринговa.
# Ми нигде нисмо рекли да ова функција треба да прима само бројеве.
# И ми нигде нисмо рекли да резултат треба да буде број.
# ПРОГРАМИ РАДЕ ОНО ШТО ИМ КАЖЕМО, НЕ ОНО ШТО СМО ЖЕЛЕЛИ ДА ИМ КАЖЕМО
# Програм ће оператор + користити на различит начин
# у зависности од тога шта су му операнди.
# Ако нам је важно да се улазни параметри понашају као неки специфичан тип податка,
# мораћемо да их кастујемо

dalje()

# Постоје начини да позиви функција буду лакши за читање и рад. Можемо да предложимо
# да аргументи треба да буду неког специфичног типа податка, као и да очекујемо да ће
# повратна вредност функције бити неки специфични тип податка.

def razlika (umanjenik: int, umanjilac: int) -> int:
    return umanjenik - umanjilac

# Сада, када смо овако дефинисали функцију, када је будемо куцали у едитору, видећемо
# назнаку да треба да очекује да умаљеник и умањилац буду цели бројеви, и да функција
# треба да врати цео број.
# Можете слободно пробати овде.

a = 4
b = 6
c = razlika (b, a)
print (b, "-", a, "=", c)

dalje()

# Назначавање НЕ ЗНАЧИ да ће функција да их употреби на овај начин. 
# Ако јој проследимо реалне бројеве, и даље ће користити реалне бројеве.
# Ово је велика разлика између Пајтона и многих других програмских језика

a = 4.3
b = 6
c = razlika (b, a)
print (b, "-", a, "=", c)

dalje()

# Када прослеђујемо аргументе, уместо да их уносимо редом, можемо да их унесимо
# и преко имена њихових параметара, којим год хоћемо редом.

a = 3
b = 8
c = razlika(umanjilac=a, umanjenik=b)
print (b, "-", a, "=", c)

# Покушајте сами да откуцате позив на овај начин, видећете како вам едитор помаже
# са испуњавањем. Када радите са сложенијим функцијама, уме да буде корисно.

dalje()

# Последња ствар коју ћемо за сада да пређемо је да функције могу имати параметре
# који имају неку подразумевану вредност. Када параметар има подразумевану вредност,
# можемо га прескочити приликом позива функције - његова подразумевана вредност ће бити
# узета као аргумент. Када наводимо подразумеване параметре у дефиницији функције, они
# морају бити наведени после параметара којима није дата подразумевана вредност

def uzmi_jos(koliko, pocetak=0):
    print ("Имамо", pocetak, "јабука и узећемо још", koliko)
    return pocetak + koliko

print ("Овде имамо", uzmi_jos(5), "јабука.")
print ("Овде имамо", uzmi_jos(5,4), "јабука.")

# Унутар позива функције, можемо да проследимо обичне аргументе без да им кажемо
# име параметра, ослањајући се на њихов редослед, а да онда после по имену додамо
# ком подразумеваном параметру ипак желимо да дамо неки други аргумент. Ово је корисно
# када функција има велик број подразумеваних параметара, а ми желимо да изменимо
# само ограничен број њих.

print ("Овде имамо", uzmi_jos(3,pocetak=7), "јабука.")

print()
print ("КРАЈ ПРОГРАМА")






