# Пре овога погледати:
# objasnjenje_grananja.py
# objasnjenje_skupova.py
# objasnjenje_nizova.py

def dalje(sekcija = None):
    print()
    if sekcija!=None: print ("Секција:", sekcija)
    input ("Притисните ентер да наставите")
    print()

print ("##################################################")
print()

# WHILE петља има логички услов уласка. Када се први пут наиђе на петљу, 
# проверава се условда би се у петљу уопште ушло. 
# И наравно, сваки пут када се петља заврши, услов се поново проверава.

uslov = False
while uslov:
    print ("Ушли смо у петљу")

# У ову петљу програм никад неће ући јер је услов уласка у њу увек неистинит.
# Ако у коду измените uslov на вредност True, ова петља ће постати бесконачна.
# Притисните control и C у исто време да прекинете програм кад упадне у овакву петљу.
# Бесконачна петља настаје када услов уласка у њу увек истинит, односно кад је услов
# изласка из ње увек неистинит. Препознавање бесконачних петљи је важна вештина.

dalje(1)

# Следећа петља није бесконачна, јер корисник увек може да пошаље сигнал за излазак.

ostani_u_petlji = True
while ostani_u_petlji:
    ulaz = input ("Напишите 1 да изађете из петље: ")
    ostani_u_petlji = False if ulaz == "1" else True

dalje(2)

# Ако неки други део програма треба да доведе ову петљу у стање које се може
# завршити, петља зависи од тог другог дела програма, и може бити бесконачна ако
# тај део програма не ради како треба, иако је петља коректно написана.
# ГРЕШКА НЕ НАСТАЈЕ УВЕК ТАМО ГДЕ СМО ЈЕ ПРИМЕТИЛИ

def spoljasnja_funkcija(konzolni_ulaz, ciljna_vrednost):
    return False if konzolni_ulaz == str(ciljna_vrednost) else True

# Ако ову функцију измените да увек враћа True, петља испод ће бити бесконачна

ostani_u_petlji = True
cilj = 123
while ostani_u_petlji:
    ulazni_string = "Напишите " + str(cilj) + " да изађете из петље: "
    # У input() не можемо да директно шаљемо стринг са променљивама као у print()
    # па га припремамо одвојено
    ulaz = input(ulazni_string)
    ostani_u_petlji = spoljasnja_funkcija(ulaz, cilj)

# Ако се spoljasnja_funkcija() измени тако да јој је у провери
# konzolni_ulaz == str(ciljna_vrednost)
# уместо поређења са параметром ciljna_vrednost, буде == "neka glupost"
# биће и даље могуће изаћи из петље (напиши "neka glupost"), али корисник неће знати,
# па је ова петља ипак нешто што можемо звати бесконачном петљом.
# То што строго говорећи има испуњив услов изласка не значи ништа
# ако се тај услов реално никад неће десити.

dalje(3)

# Петље са бројачем се ретко користе у Пајтону, и обично се изводе на мало другачији
# начин, али овако би им изгледао општи облик:

i = 0 # Иницијализација
while i<5: # Услов
    print (i) # Тело / блок
    i+=1 # Измена бројача
# У неким другим језицима, на пример C++, овоме одговара петља for(i = 0; i<5; i++)
# с тим да је овде i променљива која важи и изван петље,
# док у овој другој формулацији она важи само унутар петље

dalje(4)

# Кључна реч BREAK нам служи да искочимо из петље.
# На следећем примеру можемо да видимо како ради.

while True:
    print ("Ушли смо у петљу")
    break
    print ("Ово је иза break")

# Ово није бесконачна петља, иако нам је услов уласка увек испуњен.
# Услов изласка нам је овде да смо дошли до линије кода break
# Ако користите VSCode, приметиће те да је други print() тамнији.
# То је зато што је немогуће да се тај код икад изврши - петља ће увек бити прекинута
# кад дођемо то break-а.

dalje(5)

# Ово се може користити да се направи нешто налик на DO WHILE петљу

while (True):
    ulaz = input ("Унесите нешто: ")
    if ulaz == "":
        print ("Нисте унели ништа")
    else:
        break

# Ова петља ће се вртети док год будемо само притискали ентер.
# Чим нешто прво и унесемо, петља ће наићи на break и зауставити се.

dalje(6)

# Кључна реч CONTINUE у Пајтону значи "врати се одмах на почетак петље"
# Користи се када имамо желимо да прескочимо остатак тренутне итерације
# или када већ знамо да за њим неће бити потребе

while (True):
    ulaz = input("Унесите 100 да наставите: ")
    if ulaz == "":
        print ("Нисте унели ништа.")
        continue
    print ("Унели сте:", ulaz)
    if ulaz == "100":
        print ("То је тачан начин да се заврши петља")
        break
    else:
        print ("То није тачан начин да се заврши петља.")

# Овакав код је незгодно представити графом тока програма.
# Треба избегавати претерану употребу continue и break ако се може радити и без њих
# Предности које пружају треба да буду веће од проблема које могу да изазову

dalje(7)

# WHILE петља такође може имати свој ELSE блок. Тај блок се извршава кад се улазни
# услов провери и није испуњен, без обзира да ли смо улазили у петљу или не.
# Међутим, тај блок се неће извршити ако из петље изађемо преко команде BREAK 

dozvoljeno_pokusaja = 5
broj_pokusaja = 0
while (broj_pokusaja<dozvoljeno_pokusaja):
    ulaz = input ("Унесите 500: ")
    broj_pokusaja += 1
    if ulaz == "500": 
        print ("Браво.")
        break
    else:
        print ("То није 500")
else:
    print("Ни после", dozvoljeno_pokusaja, "покушаја нисте унели 500")
print ("Петља је сада завршена")

# Оваквом петљом спречавамо да се унос бесконачно врти ако нешто не иде
# и после довољно покушаја можемо да унос прогласимо неуспехом и видимо шта ћемо даље.

dalje(8)

# FOR IN петља се користи да се обради сви поједини елементи неке групе података
# На пример, ако имамо скуп, обрадиће све елементе скупа, један по један
# FOR појединац IN група: изврши блок

skup = {"nesto", 1, 2, "nesto drugo"}
for element in skup:
    print ("Сада обрађујемо ", str(element))
# Приметите да се опет не исписује оних редом којим је написано у скупу

# Ова петља се извршава на следећи начин:
# Узима се нешто из групе података (овде је то скуп skup) што још није узето
# То нешто се смешта смешта у променљиву која прати појединце (овде је то element)
# Извршава се блок петље, користећи ту вредност
# Када се заврши блок, проверава се да ли има још елемената за обраду
# Ако нема, завршавамо петљу. Ако има, узимамо наредни.

dalje(9)

# Слично можемо наћи суму низа бројева:

niz = [1, 5, 1, 12, 4]
print (niz)
suma = 0
print ("Почињемо од", suma)
for broj in niz:
    suma += broj
    print ("Додајемо", broj, "и сума је сад", suma)
print ("Сума овог низа је:", suma)
# Обратите пажњу да смо овај пут прошли кроз елементе редом

dalje(10)

# И овде можемо да користимо ELSE, BREAK, и CONTINUE

učenici_u_učionici = ["Стефан", "Данило", "Милица"]
učenik_koga_tražimo = "Данило"
broj_učenika_koje_smo_pitali = 0

for učenik in učenici_u_učionici:
    broj_učenika_koje_smo_pitali += 1
    if učenik == učenik_koga_tražimo:
        print (učenik, "је ту!")
        break
    else:
        print (učenik, "није тај ученик.")
else:
    print (učenik, "није ту!")
print ("Број ученика које смо питали како се зову:", broj_učenika_koje_smo_pitali)

# Ако вас занима тачно како ово ради, промените низ učenici_u_učionici и видите
# шта ће се десити. Који је број ученика који су питани како се зову? Зашто?
# Шта ће се десити ако је низ празан?
# Ако нећете да извршавате цео овај програм само да би тестирали овај део,
# направите нови фајл и прекопирајте код између овог и претходног коментара,
# и онда тамо тестирајте.
